//! Framebuffer Console Driver
//!
//! Provides pixel-based text rendering using GOP framebuffer.
//! This is the modern approach (like Linux fbcon) instead of legacy VGA text mode.

use core::fmt;
use core::ptr;
use spin::Mutex;

/// Physical memory offset for high-half mapping
const PHYS_OFFSET: u64 = 0xffff_ffff_8000_0000;

/// Default console colors (ARGB format)
const FG_COLOR: u32 = 0x00AAAAAA; // Light gray foreground
const BG_COLOR: u32 = 0x00000000; // Black background

/// Character cell dimensions (8x16 font)
const CHAR_WIDTH: usize = 8;
const CHAR_HEIGHT: usize = 16;

/// Pixel format
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub enum PixelFormat {
    Rgb = 0,
    Bgr = 1,
    Unknown = 2,
}

/// Framebuffer information passed from bootloader
#[derive(Debug, Clone, Copy)]
#[repr(C)]
pub struct FramebufferInfo {
    pub base: u64,
    pub size: usize,
    pub width: u32,
    pub height: u32,
    pub stride: u32,
    pub pixel_format: PixelFormat,
}

/// Framebuffer console writer
pub struct FramebufferWriter {
    /// Framebuffer base virtual address
    fb_base: u64,
    /// Width in pixels
    width: u32,
    /// Height in pixels
    height: u32,
    /// Bytes per scanline
    stride: u32,
    /// Pixel format
    pixel_format: PixelFormat,
    /// Current cursor column (in characters)
    col: usize,
    /// Current cursor row (in characters)
    row: usize,
    /// Maximum columns
    max_col: usize,
    /// Maximum rows
    max_row: usize,
    /// Foreground color (ARGB)
    fg_color: u32,
    /// Background color (ARGB)
    bg_color: u32,
    /// Whether framebuffer is initialized
    initialized: bool,
    /// R24-8 fix: Validated framebuffer size in bytes
    /// All pixel writes must stay within this bound
    fb_size: usize,
}

impl FramebufferWriter {
    /// Create an uninitialized writer
    pub const fn new() -> Self {
        Self {
            fb_base: 0,
            width: 0,
            height: 0,
            stride: 0,
            pixel_format: PixelFormat::Bgr,
            col: 0,
            row: 0,
            max_col: 0,
            max_row: 0,
            fg_color: FG_COLOR,
            bg_color: BG_COLOR,
            initialized: false,
            fb_size: 0,
        }
    }

    /// Initialize with framebuffer info
    pub fn init(&mut self, info: &FramebufferInfo) {
        // R24-8 fix: Validate framebuffer dimensions before using
        // Check that stride * height (in bytes) doesn't exceed provided size
        // stride is in pixels, so multiply by 4 for bytes
        let stride_bytes = (info.stride as usize).saturating_mul(4);
        let required_size = stride_bytes.saturating_mul(info.height as usize);

        if info.size == 0 || required_size > info.size {
            // Invalid framebuffer info - dimensions exceed buffer size
            // Refuse to initialize to prevent out-of-bounds writes
            return;
        }

        // Also validate that width fits within stride
        if info.width > info.stride {
            return;
        }

        // Calculate virtual address for framebuffer
        //
        // The bootloader sets up identity mapping for 0-4GB, so we can access
        // the framebuffer at its physical address directly.
        //
        // However, identity mapping will be hardened (made read-only) during
        // security initialization. To avoid this, we use the high-half direct
        // mapping if the address is within range, otherwise we need to create
        // a dedicated mapping.
        //
        // Bootloader maps physical 0-1GB to virtual 0xffffffff80000000-...
        // For framebuffer addresses beyond 1GB (common for GOP), we need
        // to use identity mapping and mark it as MMIO-exempt during hardening.
        //
        // Note: Framebuffer physical address is typically:
        // - 0x80000000 (2GB) for QEMU/OVMF
        // - Could be higher on real hardware
        self.fb_base = if info.base < 0x4000_0000 {
            // Within first 1GB - can use high-half mapping
            info.base + PHYS_OFFSET
        } else {
            // Beyond high-half mapping - use identity mapping
            // The security module should preserve this as writable MMIO
            info.base
        };

        self.width = info.width;
        self.height = info.height;
        // IMPORTANT: UEFI GOP stride is in PIXELS, convert to BYTES (4 bytes per pixel)
        self.stride = info.stride * 4;
        self.pixel_format = info.pixel_format;
        self.max_col = (info.width as usize) / CHAR_WIDTH;
        self.max_row = (info.height as usize) / CHAR_HEIGHT;
        self.col = 0;
        self.row = 0;
        self.initialized = true;
        // R24-8 fix: Store validated framebuffer size for bounds checking
        self.fb_size = info.size;

        // Store framebuffer info for security module to access
        unsafe {
            FRAMEBUFFER_PHYS_BASE = info.base;
            FRAMEBUFFER_SIZE = info.size;
        }

        // Clear screen with background color
        self.clear_screen();
    }

    /// Check if writer is initialized
    #[inline]
    pub fn is_initialized(&self) -> bool {
        self.initialized
    }

    /// Write a single pixel
    #[inline]
    fn put_pixel(&mut self, x: u32, y: u32, color: u32) {
        if !self.initialized || x >= self.width || y >= self.height {
            return;
        }

        let offset = (y as u64 * self.stride as u64 + x as u64 * 4) as usize;

        // R24-8 fix: Check that write stays within validated framebuffer bounds
        // This prevents out-of-bounds writes if GOP info has incorrect stride
        if offset.saturating_add(4) > self.fb_size {
            return;
        }

        let pixel_addr = self.fb_base + offset as u64;

        // Convert color based on pixel format
        let pixel_value = match self.pixel_format {
            PixelFormat::Rgb => {
                // ARGB -> RGB (swap R and B)
                let r = (color >> 16) & 0xFF;
                let g = (color >> 8) & 0xFF;
                let b = color & 0xFF;
                (r << 16) | (g << 8) | b
            }
            PixelFormat::Bgr => {
                // ARGB -> BGR (keep as is, B is already in low byte)
                let r = (color >> 16) & 0xFF;
                let g = (color >> 8) & 0xFF;
                let b = color & 0xFF;
                (b << 16) | (g << 8) | r
            }
            PixelFormat::Unknown => color,
        };

        unsafe {
            ptr::write_volatile(pixel_addr as *mut u32, pixel_value);
        }
    }

    /// Draw a character at the specified character position
    fn draw_char(&mut self, c: char, char_col: usize, char_row: usize) {
        let px = (char_col * CHAR_WIDTH) as u32;
        let py = (char_row * CHAR_HEIGHT) as u32;

        // Get font bitmap for this character
        let bitmap = get_font_bitmap(c);

        for row in 0..CHAR_HEIGHT {
            let bits = bitmap[row];
            for col in 0..CHAR_WIDTH {
                let color = if (bits >> (7 - col)) & 1 == 1 {
                    self.fg_color
                } else {
                    self.bg_color
                };
                self.put_pixel(px + col as u32, py + row as u32, color);
            }
        }
    }

    /// Clear a character cell
    fn clear_char(&mut self, char_col: usize, char_row: usize) {
        let px = (char_col * CHAR_WIDTH) as u32;
        let py = (char_row * CHAR_HEIGHT) as u32;

        for row in 0..CHAR_HEIGHT {
            for col in 0..CHAR_WIDTH {
                self.put_pixel(px + col as u32, py + row as u32, self.bg_color);
            }
        }
    }

    /// Clear entire screen
    pub fn clear_screen(&mut self) {
        if !self.initialized {
            return;
        }

        // Fast fill: write entire framebuffer
        let total_bytes = self.height as usize * self.stride as usize;

        // R24-8 fix: Clamp to validated framebuffer size
        let safe_bytes = total_bytes.min(self.fb_size);

        let pixel_value = match self.pixel_format {
            PixelFormat::Bgr => {
                let r = (self.bg_color >> 16) & 0xFF;
                let g = (self.bg_color >> 8) & 0xFF;
                let b = self.bg_color & 0xFF;
                (b << 16) | (g << 8) | r
            }
            _ => self.bg_color,
        };

        // Fill 4 bytes at a time
        let ptr = self.fb_base as *mut u32;
        let count = safe_bytes / 4;
        for i in 0..count {
            unsafe {
                ptr::write_volatile(ptr.add(i), pixel_value);
            }
        }

        self.col = 0;
        self.row = 0;
    }

    /// Scroll screen up by one line
    fn scroll_up(&mut self) {
        if !self.initialized {
            return;
        }

        // Copy each line up
        let line_bytes = self.stride as usize * CHAR_HEIGHT;
        let src_start = self.fb_base + line_bytes as u64;
        let dst_start = self.fb_base;
        let copy_bytes = (self.max_row - 1) * line_bytes;

        // R24-8 fix: Validate that operations stay within framebuffer bounds
        let total_needed = (self.max_row * line_bytes).saturating_add(line_bytes);
        if total_needed > self.fb_size {
            // Framebuffer too small for scroll operation, skip
            return;
        }

        // Copy line by line to handle overlapping regions
        for row in 0..(self.max_row - 1) {
            let src = src_start + (row * line_bytes) as u64;
            let dst = dst_start + (row * line_bytes) as u64;

            // R24-8 fix: Check bounds for each line copy
            let dst_offset = (row * line_bytes) as usize;
            let src_offset = dst_offset.saturating_add(line_bytes);
            if src_offset.saturating_add(line_bytes) > self.fb_size {
                break;
            }

            unsafe {
                ptr::copy(src as *const u8, dst as *mut u8, line_bytes);
            }
        }

        // Clear the last line
        let last_line_offset = (self.max_row - 1) * line_bytes;
        if last_line_offset.saturating_add(line_bytes) > self.fb_size {
            return;
        }

        let last_line_start = self.fb_base + last_line_offset as u64;
        let pixel_value = match self.pixel_format {
            PixelFormat::Bgr => {
                let r = (self.bg_color >> 16) & 0xFF;
                let g = (self.bg_color >> 8) & 0xFF;
                let b = self.bg_color & 0xFF;
                (b << 16) | (g << 8) | r
            }
            _ => self.bg_color,
        };

        let ptr = last_line_start as *mut u32;
        let count = line_bytes / 4;
        for i in 0..count {
            unsafe {
                ptr::write_volatile(ptr.add(i), pixel_value);
            }
        }
    }

    /// Write a single byte
    pub fn write_byte(&mut self, byte: u8) {
        if !self.initialized {
            return;
        }

        match byte {
            b'\n' => {
                self.col = 0;
                self.row += 1;
                if self.row >= self.max_row {
                    self.scroll_up();
                    self.row = self.max_row - 1;
                }
            }
            b'\r' => {
                self.col = 0;
            }
            b'\t' => {
                // Tab: advance to next 8-character boundary
                let next = (self.col + 8) & !7;
                for _ in self.col..next.min(self.max_col) {
                    self.clear_char(self.col, self.row);
                    self.col += 1;
                }
                if self.col >= self.max_col {
                    self.col = 0;
                    self.row += 1;
                    if self.row >= self.max_row {
                        self.scroll_up();
                        self.row = self.max_row - 1;
                    }
                }
            }
            0x08 => {
                // Backspace
                if self.col > 0 {
                    self.col -= 1;
                    self.clear_char(self.col, self.row);
                }
            }
            byte => {
                // Printable character
                if self.col >= self.max_col {
                    self.col = 0;
                    self.row += 1;
                    if self.row >= self.max_row {
                        self.scroll_up();
                        self.row = self.max_row - 1;
                    }
                }
                let c = if byte >= 0x20 && byte < 0x7f {
                    byte as char
                } else {
                    '?' // Replace unprintable with '?'
                };
                self.draw_char(c, self.col, self.row);
                self.col += 1;
            }
        }
    }

    /// Write a string
    pub fn write_string(&mut self, s: &str) {
        for byte in s.bytes() {
            self.write_byte(byte);
        }
    }
}

impl fmt::Write for FramebufferWriter {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        self.write_string(s);
        Ok(())
    }
}

/// Global framebuffer writer
pub static WRITER: Mutex<FramebufferWriter> = Mutex::new(FramebufferWriter::new());

/// Framebuffer physical base address (for security module to query)
static mut FRAMEBUFFER_PHYS_BASE: u64 = 0;
/// Framebuffer size in bytes
static mut FRAMEBUFFER_SIZE: usize = 0;

/// Get the framebuffer physical memory region
///
/// Returns (base_phys_addr, size) if framebuffer is initialized, None otherwise.
/// Used by security module to preserve this region as writable during identity
/// map hardening.
pub fn get_framebuffer_region() -> Option<(u64, usize)> {
    unsafe {
        if FRAMEBUFFER_PHYS_BASE != 0 && FRAMEBUFFER_SIZE != 0 {
            Some((FRAMEBUFFER_PHYS_BASE, FRAMEBUFFER_SIZE))
        } else {
            None
        }
    }
}

/// Initialize framebuffer console with info from bootloader
pub fn init(info: &FramebufferInfo) {
    WRITER.lock().init(info);
}

/// Check if framebuffer is initialized
pub fn is_initialized() -> bool {
    WRITER.lock().is_initialized()
}

/// Print function used by macros
#[doc(hidden)]
pub fn _print(args: fmt::Arguments) {
    use core::fmt::Write;
    WRITER.lock().write_fmt(args).unwrap();
}

// ============================================================================
// 8x16 Bitmap Font
// ============================================================================

/// Get font bitmap for a character (8x16 pixels)
fn get_font_bitmap(c: char) -> [u8; CHAR_HEIGHT] {
    let idx = c as usize;
    if idx >= 0x20 && idx < 0x7f {
        FONT_8X16[idx - 0x20]
    } else {
        FONT_8X16[0] // Space for unknown characters
    }
}

/// 8x16 bitmap font for ASCII characters 0x20-0x7E
/// Each character is 16 bytes, one byte per row (8 pixels)
static FONT_8X16: [[u8; 16]; 95] = [
    // 0x20 ' ' (space)
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x21 '!'
    [
        0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x22 '"'
    [
        0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x23 '#'
    [
        0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x24 '$'
    [
        0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00,
        0x00,
    ],
    // 0x25 '%'
    [
        0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x26 '&'
    [
        0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x27 '''
    [
        0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x28 '('
    [
        0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x29 ')'
    [
        0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x2A '*'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x2B '+'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x2C ','
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00,
        0x00,
    ],
    // 0x2D '-'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x2E '.'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x2F '/'
    [
        0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x30 '0'
    [
        0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xD6, 0xD6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x31 '1'
    [
        0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x32 '2'
    [
        0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x33 '3'
    [
        0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x34 '4'
    [
        0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x35 '5'
    [
        0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x36 '6'
    [
        0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x37 '7'
    [
        0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x38 '8'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x39 '9'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3A ':'
    [
        0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3B ';'
    [
        0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3C '<'
    [
        0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3D '='
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3E '>'
    [
        0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x3F '?'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x40 '@'
    [
        0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x41 'A'
    [
        0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x42 'B'
    [
        0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x43 'C'
    [
        0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x44 'D'
    [
        0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x45 'E'
    [
        0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x46 'F'
    [
        0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x47 'G'
    [
        0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x48 'H'
    [
        0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x49 'I'
    [
        0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4A 'J'
    [
        0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4B 'K'
    [
        0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4C 'L'
    [
        0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4D 'M'
    [
        0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4E 'N'
    [
        0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x4F 'O'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x50 'P'
    [
        0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x51 'Q'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00,
        0x00,
    ],
    // 0x52 'R'
    [
        0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x53 'S'
    [
        0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x54 'T'
    [
        0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x55 'U'
    [
        0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x56 'V'
    [
        0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x57 'W'
    [
        0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x58 'X'
    [
        0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x59 'Y'
    [
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5A 'Z'
    [
        0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5B '['
    [
        0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5C '\'
    [
        0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5D ']'
    [
        0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5E '^'
    [
        0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x5F '_'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
        0x00,
    ],
    // 0x60 '`'
    [
        0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x61 'a'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x62 'b'
    [
        0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x63 'c'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x64 'd'
    [
        0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x65 'e'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x66 'f'
    [
        0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x67 'g'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78,
        0x00,
    ],
    // 0x68 'h'
    [
        0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x69 'i'
    [
        0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x6A 'j'
    [
        0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C,
        0x00,
    ],
    // 0x6B 'k'
    [
        0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x6C 'l'
    [
        0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x6D 'm'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x6E 'n'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x6F 'o'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x70 'p'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0,
        0x00,
    ],
    // 0x71 'q'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E,
        0x00,
    ],
    // 0x72 'r'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x73 's'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x74 't'
    [
        0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x75 'u'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x76 'v'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x77 'w'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x78 'x'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x79 'y'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8,
        0x00,
    ],
    // 0x7A 'z'
    [
        0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x7B '{'
    [
        0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x7C '|'
    [
        0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x7D '}'
    [
        0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00,
        0x00,
    ],
    // 0x7E '~'
    [
        0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ],
];
